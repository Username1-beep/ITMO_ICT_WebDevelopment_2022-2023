<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="None">
    
    
    <link rel="shortcut icon" href="./img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Web Development by Me</title>
    <link href="./css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="./css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="./css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="./css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="./js/jquery-3.2.1.min.js"></script>
    <script src="./js/bootstrap-3.3.7.min.js"></script>
    <script src="./js/highlight.pack.js"></script>
    
      <script src="./js/elasticlunr.min.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '.';
      var is_top_frame = (window === window.parent);
        
        var pageToc = [
          {title: "\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 1", url: "#_top", children: [
              {title: "\u0420\u0430\u0431\u043e\u0442\u0430 \u0441 \u0441\u043e\u043a\u0435\u0442\u0430\u043c\u0438", url: "#_1" },
              {title: "\u0417\u0430\u0434\u0430\u043d\u0438\u0435 1", url: "#1_1" },
              {title: "\u0417\u0430\u0434\u0430\u043d\u0438\u0435 2", url: "#2" },
              {title: "\u0417\u0430\u0434\u0430\u043d\u0438\u0435 3", url: "#3" },
              {title: "\u0417\u0430\u0434\u0430\u043d\u0438\u0435 4", url: "#4" },
              {title: "\u0417\u0430\u0434\u0430\u043d\u0438\u0435 5", url: "#5" },
          ]},
        ];

    </script>
    <script src="./js/base.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>

<nav class="navbar wm-page-top-frame">
  <div class="container-fluid wm-top-container">
    
    <div class="wm-top-tool pull-right wm-vcenter">
      <form class="dropdown wm-vcentered" id="wm-search-form" action="./search.html">
        
        <button id="wm-search-show" class="btn btn-sm btn-default" type="submit"
          ><i class="fa fa-search" aria-hidden="true"></i></button>

        <div class="input-group input-group-sm wm-top-search">
          <input type="text" name="q" class="form-control" id="mkdocs-search-query" placeholder="Search" autocomplete="off">
          <span class="input-group-btn" role="search">
            
            <button class="btn btn-default dropdown-toggle collapse" data-toggle="dropdown" type="button"><span class="caret"></span></button>
            <ul id="mkdocs-search-results" class="dropdown-menu dropdown-menu-right"></ul>
            <button id="wm-search-go" class="btn btn-default" type="submit"><i class="fa fa-search" aria-hidden="true"></i></button>
          </span>
        </div>
      </form>
    </div>

    
    <div class="wm-top-tool wm-vcenter pull-right wm-small-left">
      <button id="wm-toc-button" type="button" class="btn btn-sm btn-default wm-vcentered"><i class="fa fa-th-list" aria-hidden="true"></i></button>
    </div>

    
    

    
    <a href="" class="wm-top-brand wm-top-link wm-vcenter">
      
      <div class="wm-top-title">
        Web Development by Me<br>
        
      </div>
    </a>
  </div>
</nav>

  <div id="main-content" class="wm-page-top-frame">
    
<nav class="wm-toc-pane">
  
  <ul class="wm-toctree">
        <li class="wm-toc-li wm-toc-lev1 "><a href="" class="wm-article-link wm-toc-text">Лабораторная работа 1</a>
</li>
  </ul>
</nav>

    <div class="wm-content-pane">
      <iframe class="wm-article" name="article"></iframe>
    </div>
  </div>

<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    

    <h1 id="1">Лабораторная работа 1</h1>
<h2 id="_1">Работа с сокетами</h2>
<h2 id="1_1">Задание 1</h2>
<p>Реализовать клиентскую и серверную часть приложения. Клиент отсылает серверу
сообщение «Hello, server». Сообщение должно отразиться на стороне сервера.
Сервер в ответ отсылает клиенту сообщение «Hello, client». Сообщение должно
отобразиться у клиента.</p>
<p>Обязательно использовать библиотеку <code>socket</code></p>
<p>Реализовать с помощью протокола <code>UDP</code></p>
<h4 id="_2">Клиентская часть</h4>
<pre><code>import socket

my_socket = socket.socket(socket.SOCK_DGRAM)
my_socket.connect((&quot;127.0.0.10&quot;, 12400))
msg = &quot;Hello, server!&quot;
my_socket.send(msg.encode(&quot;utf-8&quot;))
data = my_socket.recv(16384)
print(data.decode(&quot;utf-8&quot;))
my_socket.close() 
</code></pre>
<p>Создаем сокет <code>my_socket</code> и подключаемся к серверу:</p>
<pre><code>my_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
my_socket.connect((&quot;127.0.0.1&quot;, 12400))
</code></pre>
<p>Отправляем на сервер сообщение "Hello, server!":</p>
<pre><code>msg = &quot;Hello, server!&quot;
my_socket.send(msg.encode(&quot;utf-8&quot;))
</code></pre>
<p>Получаем сообщение от сервера, печатаем его и закрываем соединение:</p>
<pre><code>data = my_socket.recv(16384)
print(data.decode(&quot;utf-8&quot;))
my_socket.close() 
</code></pre>
<h4 id="_3">Серверная часть</h4>
<pre><code>import socket

my_socket = socket.socket(socket.SOCK_DGRAM)
my_socket.bind((&quot;127.0.0.10&quot;, 12400))
my_socket.listen(10)

sock, address = my_socket.accept()
data = sock.recv(16384)
data = data.decode(&quot;utf-8&quot;)
print(data)
msg = &quot;Hello, client!&quot;
sock.send(msg.encode(&quot;utf-8&quot;))
my_socket.close()
</code></pre>
<p>Создаем сокет <code>my_socket</code> и с помощью метода <code>.listen()</code> запускаем режим прослушивания:</p>
<pre><code>my_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
my_socket.bind((&quot;127.0.0.1&quot;, 12400))
my_socket.listen(10)
</code></pre>
<p>Получаем сообщение от клиента и печатаем его:</p>
<pre><code>sock, address = my_socket.accept()
data = sock.recv(16384)
data = data.decode(&quot;utf-8&quot;)
print(data)
</code></pre>
<p>Отправляем клиенту сообщение "Hello, client!" и закрываем соединение:</p>
<pre><code>msg = &quot;Hello, client!&quot;
sock.send(msg.encode(&quot;utf-8&quot;))
my_socket.close()
</code></pre>
<h2 id="2">Задание 2</h2>
<p>Реализовать клиентскую и серверную часть приложения. Клиент запрашивает у
сервера решение Теоремы Пифагора, параметры которой вводятся с
клавиатуры. Сервер обрабатывает полученные данные и возвращает результат
клиенту.</p>
<p>Обязательно использовать библиотеку <code>socket</code></p>
<p>Реализовать с помощью протокола <code>TCP</code></p>
<h4 id="_4">Клиентская часть</h4>
<pre><code># Variant a. - теорема пифагора
import socket

my_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
my_socket.connect((&quot;127.0.0.1&quot;, 12400))

# Два прохода цикла, тк 2 вводных числа
for _ in range(2):
    print(my_socket.recv(16384).decode())  # Сообщение от сервера
    inp = input(&quot;&gt;&gt; &quot;)  # Вводимые катеты
    my_socket.send(inp.encode())  # Отправка на сервер

print(my_socket.recv(16384).decode())
my_socket.close()
</code></pre>
<p>Создаем сокет <code>my_socket</code> и подключаемся к серверу:</p>
<pre><code>my_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
my_socket.connect((&quot;127.0.0.1&quot;, 12400))
</code></pre>
<p>В цикле делаем два прохода, получая сообщения от сервера и посылая вводные данные:</p>
<pre><code>for _ in range(2):
    print(my_socket.recv(16384).decode())  # Сообщение от сервера
    inp = input(&quot;&gt;&gt; &quot;)  # Вводимые катеты
    my_socket.send(inp.encode())  # Отправка на сервер
</code></pre>
<p>Получаем и печатаем результат, полученный с сервера. Закрываем соединение:</p>
<pre><code>print(my_socket.recv(16384).decode())
my_socket.close()
</code></pre>
<h4 id="_5">Серверная часть</h4>
<pre><code>import socket
import math

my_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
my_socket.bind((&quot;127.0.0.1&quot;, 12400))

my_socket.listen(10)

sock, address = my_socket.accept()
sock.send(&quot;Input a:&quot;.encode())
a = int(sock.recv(16384).decode())  # Первый катет
sock.send(&quot;Input b:&quot;.encode())
b = int(sock.recv(16384).decode())  # Второй катет
c = a * a + b * b
result = math.sqrt(c)
sock.send(f&quot;The result is:\n {result}&quot;.encode())
my_socket.close()
</code></pre>
<p>Создаем сокет <code>my_socket</code> и с помощью метода <code>.listen()</code> запускаем режим прослушивания:</p>
<pre><code>my_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
my_socket.bind((&quot;127.0.0.1&quot;, 12400))
my_socket.listen(10)
</code></pre>
<p>Сервер отправляет клиенту сообщения для запроса вводных данных и принимает их:</p>
<pre><code>sock, address = my_socket.accept()
sock.send(&quot;Input a:&quot;.encode())
a = int(sock.recv(16384).decode()) 
sock.send(&quot;Input b:&quot;.encode())
b = int(sock.recv(16384).decode()) 
</code></pre>
<p>Расчет длины гипотенузы из двух катетов по Теореме Пифагора:</p>
<pre><code>c = a * a + b * b
result = math.sqrt(c)
</code></pre>
<p>Сервер отправляет результат расчета клиенту и закрывает соединение:</p>
<pre><code>sock.send(f&quot;The result is:\n {result}&quot;.encode())
my_socket.close()
</code></pre>
<h2 id="3">Задание 3</h2>
<p>Реализовать серверную часть приложения. Клиент подключается к серверу. В ответ
клиент получает http-сообщение, содержащее html-страницу, которую сервер
подгружает из файла index.html.</p>
<p>Обязательно использовать библиотеку <code>socket</code></p>
<pre><code>import socket

my_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
my_socket.bind(('127.0.0.1', 14900))
my_socket.listen(10)


def main():
    while True:
        try:
            client, _ = my_socket.accept()
            client.recv(4096)
            response_type = &quot;HTTP/1.0 200 OK\n&quot;
            headers = &quot;Content-Type: text/html\n\n&quot;
            with open(&quot;index.html&quot;, &quot;r&quot;) as f:
                body = f.read()
            resp = response_type + headers + body
            client.send(resp.encode())
            client.close()
        except KeyboardInterrupt:
            my_socket.close()
            break


if __name__ == '__main__':
    main()
</code></pre>
<h2 id="4">Задание 4</h2>
<p>Реализовать двухпользовательский или многопользовательский чат. Реализация
многопользовательского часа позволяет получить максимальное количество
баллов.</p>
<p>Обязательно использовать библиотеку <code>socket</code></p>
<p>Обязательно использовать библиотеку <code>threading</code></p>
<p>Реализовать с помощью протокола <code>TCP</code></p>
<h4 id="_6">Клиентская часть</h4>
<pre><code>import socket
import sys
from threading import Thread


class ChatClient:
    def __init__(self, host, port, username):
        self.host = host
        self.port = port
        self.username = username
        self.conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    def _send(self):
        # Многопоточная функция для отправки сообщений
        while True:
            try:
                msg = input()
                if msg:
                    self.conn.send(f&quot;{self.username}: {msg}&quot;.encode())
            except (KeyboardInterrupt, EOFError):
                self.conn.close()
                sys.exit(0)

    def _recieve(self):
        # Многопоточная функция для получения сообщений
        while True:
            try:
                msg = self.conn.recv(16384).decode()
                if msg:
                    print(msg)
            except KeyboardInterrupt:
                self.conn.close()
                sys.exit(0)
            except ConnectionError:
                # Ошибка подключения
                print(&quot;Connection error&quot;)
                self.conn.close()
                sys.exit(1)

    def run(self):
        # Подключение
        self.conn.connect((self.host, self.port))
        # Запуск многопоточной функции
        Thread(target=self._send).start()
        Thread(target=self._recieve).start()


if __name__ == '__main__':
    u = input(&quot;Your username: &quot;)
    print(f&quot;Hello {u}&quot;)
    print(&quot;Connecting to server...&quot;)
    client = ChatClient('127.0.0.1', 14900, u)
    client.run()
</code></pre>
<h4 id="_7">Серверная часть</h4>
<pre><code>import socket
import sys
from threading import Thread


class ChatServer:

    def __init__(self, host: str, port: int):
        self.clients = []
        self.host = host
        self.port = port
        self.conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    def _shutdown(self):
        for sock in self.clients:
            sock.close()
        self.conn.close()
        sys.exit(0)

    def _client_broadcast(self, message: bytes, sender: socket.socket) -&gt; None:
        # Отправка сообщения клиента другим клиентам
        for sock in self.clients.copy():
            if sock != sender:
                try:
                    sock.send(message)
                except OSError:
                    # Клиент отключился
                    print(&quot;Someone disconnected&quot;)
                    self.clients.remove(sock)

    def _client_listen(self, sock: socket.socket) -&gt; None:
        # Ожидание сообщения от клиента
        sock.settimeout(30)
        while True:
            try:
                message = sock.recv(16384)
                print(message.decode())
                self._client_broadcast(message, sock)
            except OSError:
                sock.close()
                break

    def _main(self) -&gt; None:
        # Запуск сервера
        self.conn.bind((self.host, self.port))
        self.conn.listen(10)
        while True:
            try:
                # Подтверждение подключения
                sock, address = self.conn.accept()
                print(f&quot;Connection at {address}&quot;)
                # Создание потока для клиентов
                self.clients.append(sock)
                Thread(target=self._client_listen, args=(sock,)).start()
            except KeyboardInterrupt:
                self._shutdown()

    def run(self) -&gt; None:
        # Упаковщик для запуска многопоточной функции _main()
        Thread(target=self._main).start()


if __name__ == '__main__':
    print(&quot;Starting server...&quot;)
    server = ChatServer('127.0.0.1', 14900)
    server.run()
    print(&quot;Server started&quot;)
</code></pre>
<h2 id="5">Задание 5</h2>
<p>Необходимо написать простой web-сервер для обработки GET и POST http
запросов средствами Python и библиотеки socket.</p>
<p>Задание: сделать сервер, который может:</p>
<p>● Принять и записать информацию о дисциплине и оценке по дисциплине.</p>
<p>● Отдать информацию обо всех оценах по дсициплине в виде html-страницы.</p>
<pre><code>import socket


class MyHTTPServer:

    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.grade = []


    def serve_forever(self):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.bind((self.host, self.port))
        sock.listen()
        while True:
            client_socket, _ = sock.accept()
            self.serve_client(client_socket)


    def serve_client(self, client_socket):
        data = client_socket.recv(4096).decode('utf-8')
        request = self.parse_request(data)
        response = self.handle_request(request)
        if response:
            client_socket.send(response.encode('utf-8'))
            client_socket.close()


    def parse_request(self, data):
        data_split = data.split('\r\n')
        print(f&quot;data split : {data_split}&quot;)
        headers = data_split[0].split()
        print(f&quot;Headers : {headers}&quot;)
        body = data_split[-1]
        request = dict()

        if len(headers) == 3:

            request.update(
                {&quot;method&quot;: headers[0], &quot;url&quot;: headers[1], &quot;version&quot;: headers[2]})

            if &quot;&amp;&quot; in body:
                parametre = body.split(&quot;&amp;&quot;)
                request.update({&quot;parametrs&quot;: parametre})
                return request
            else:
                request.update({&quot;parametrs&quot;: {}})
                return request
        else:
            raise Exception(&quot;Malformed request line&quot;)


    def handle_request(self, request):
        print(request)
        response = f&quot;{request['version']} 200 OK\n\n&quot;
        if request[&quot;url&quot;] == &quot;/&quot;:
            if request[&quot;method&quot;] == &quot;POST&quot;:
                 self.grade.extend(request[&quot;parametrs&quot;])
            if request[&quot;method&quot;] == &quot;GET&quot; or &quot;POST&quot;:
                with open('insert.html') as f:
                    response += f.read()
                    return response
        if request[&quot;url&quot;] == &quot;/journal&quot;:
            response += &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;List grades&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&quot;
            for s in self.grade:
                response += f&quot;&lt;p&gt;{s} &lt;/p&gt;&quot;
            response += &quot;&lt;/body&gt;&lt;/html&gt;&quot;
            return response


if __name__ == &quot;__main__&quot;:
    host = 'localhost'
    port = 3968
    myserver = MyHTTPServer(host, port)
    try:
        myserver.serve_forever()
    except KeyboardInterrupt:
        pass
</code></pre>
<p>Параметры сервера:</p>
<pre><code>    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.grade = []
</code></pre>
<p>Запуск сервера на сокете, обработка входящих соединений:</p>
<pre><code>    def serve_forever(self):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.bind((self.host, self.port))
        sock.listen()
        while True:
            client_socket, _ = sock.accept()
            self.serve_client(client_socket)
</code></pre>
<p>Обработка клиентского подключения:</p>
<pre><code>    def serve_client(self, client_socket):
        data = client_socket.recv(4096).decode('utf-8')
        request = self.parse_request(data)
        response = self.handle_request(request)
        if response:
            client_socket.send(response.encode('utf-8'))
            client_socket.close()
</code></pre>
<p>Функция для обработки заголовка http+запроса:</p>
<pre><code>    def parse_request(self, data):
        data_split = data.split('\r\n')
        print(f&quot;data split : {data_split}&quot;)
        headers = data_split[0].split()
        print(f&quot;Headers : {headers}&quot;)
        body = data_split[-1]
        request = dict()

        if len(headers) == 3:

            request.update(
                {&quot;method&quot;: headers[0], &quot;url&quot;: headers[1], &quot;version&quot;: headers[2]})

            if &quot;&amp;&quot; in body:
                parametre = body.split(&quot;&amp;&quot;)
                request.update({&quot;parametrs&quot;: parametre})
                return request
            else:
                request.update({&quot;parametrs&quot;: {}})
                return request
        else:
            raise Exception(&quot;Malformed request line&quot;)
</code></pre>
<p>Функция для обработки url в соответствии с нужным методом:</p>
<pre><code>    def handle_request(self, request):
        print(request)
        response = f&quot;{request['version']} 200 OK\n\n&quot;
        if request[&quot;url&quot;] == &quot;/&quot;:
            if request[&quot;method&quot;] == &quot;POST&quot;:
                 self.grade.extend(request[&quot;parametrs&quot;])
            if request[&quot;method&quot;] == &quot;GET&quot; or &quot;POST&quot;:
                with open('insert.html') as f:
                    response += f.read()
                    return response
        if request[&quot;url&quot;] == &quot;/journal&quot;:
            response += &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;List grades&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&quot;
            for s in self.grade:
                response += f&quot;&lt;p&gt;{s} &lt;/p&gt;&quot;
            response += &quot;&lt;/body&gt;&lt;/html&gt;&quot;
            return response
</code></pre>

  <br>
    

    <br>
</div>

<footer class="container-fluid wm-page-content">
  <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/gristlabs/mkdocs-windmill">Windmill</a> theme by Grist Labs.</p>
</footer>

</body>
</html>
<!--
MkDocs version : 1.4.0
Build Date UTC : 2022-10-18 18:11:54.135706+00:00
-->